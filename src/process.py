# Imports 
import os
import re
import bs4
import gzip
import json
import shutil  
import requests
import subprocess
import numpy as np
import pandas as pd
from tqdm import tqdm
import networkx as nx
from bs4 import BeautifulSoup
import xml.etree.ElementTree as ET
from collections import defaultdict
from scipy.sparse import lil_matrix
from sklearn import svm


# ---------------------------------------------------------------------
# Get Data (WORKING)
# ---------------------------------------------------------------------

def get_labels(benign, malware):
    """
    Gets the labels associated with the data we are passing in. 
    """
    return [0]*len(benign) + [1]*len(malware)

# ---------------------------------------------------------------------
# parseSmaliFile (WORKING)
# ---------------------------------------------------------------------

def parseSmaliFile(content):
    """
    Parse smali code into python directory
    """
    smali_class = {}
    smaliClassName = content.readline()
    smali_class['ClassName'] = smaliClassName.split(' ')[-1][:-1]
    smali_class['Keywords'] = smaliClassName.split(' ')[1:-1]
    smali_class['Metrics'] = {'Reflections':0,'Methods':0,'Invocations':0}
    smali_class['Methods'] = []
    smali_class['Fields'] = []
    smali_class['Loader'] = []
    line = content.readline()
    try:
        while line:
            if line.startswith('.super'):
                smali_class['SuperClass'] = line.split(' ')[1][:-1]
            elif line.startswith('.annotated'):
                pass
            elif line.startswith('.source'):
                smali_class['SourceFile'] = line.split(' ')[1][1:-2]
            elif line.startswith('.implements'):
                smali_class['Implements'] = line.split(' ')[1][:-1]
            elif line.startswith('.field'):
                field = {}
                field['KeyWords'] = line.split('=')[0].split(' ')[1:-1]
                field['Name'] = line.split('=')[0].rstrip().split(' ')[-1].split(':')[0]
                field['Type'] = line.split('=')[0].rstrip().split(' ')[-1].split(':')[1][:-1]
                smali_class['Fields'].append(field)
            elif line.startswith('.method'):
                smali_class['Metrics']['Methods']+= 1
                method = {}
                method['MethodName'] = line.split(' ')[-1][:-1]
                method['Keywords'] = line.split(' ')[1:-1]
                method['Returns'] = line.split(')')[-1]
                method['Parameters'] = line.split('(')[-1].split(')')[0]
                method['Invokes'] = []
                method['LibCalls'] = []
                method['Android API'] = []
                method['ConstStrings'] = []
                method['Dependencies'] = []
                method['Code'] = []
                method['Code'].append(line)
                methodLine = content.readline().lstrip()
                while not methodLine.startswith('.end method'):
                    if "ClassLoader" in methodLine:
                        smali_class["Loader"].append(methodLine)
                    invokes = {}
                    if not methodLine == "\n":
                        method['Code'].append(methodLine)
                    if methodLine.startswith('invoke'):
                        invokes['Type'] = methodLine.split(' ')[0]
                        invokes['Class'] = \
                            methodLine.split('}')[1][1:].split('-')[0]
                        method['Dependencies']\
                            .append(methodLine.split('}')[1][1:]
                                .split('-')[0])
                        invokes['Function'] = \
                            methodLine.split('}')[1].split('>')[1]
                        if (('Landroid' in methodLine)):
                            method["Android API"].append(methodLine)
                        if (('Ljava' in invokes['Class']) or
                                ('Landroid' in invokes['Class']) or
                                ('Ljavax' in invokes['Class'])):
                            method['LibCalls'].append(invokes)
                        else:
                            method['Invokes'].append(invokes)
                        smali_class['Metrics']['Invocations']+= 1
                        if("reflect" in invokes['Function']):
                            smali_class['Metrics']['Reflections']+= 1
                    elif methodLine.startswith('const-string'):
                        method['ConstStrings'].append(methodLine.split('"')[1])
                    methodLine = content.readline().lstrip()
                method['Code'].append(methodLine)
                smali_class['Methods'].append(method)
            else:
                pass
            line = content.readline()
    except:
        print(line)
    return smali_class

# ---------------------------------------------------------------------
# A_matrix_calc (WORKING)
# ---------------------------------------------------------------------    

def A_matrix_calc(smali_dict, malware_dict):
    """
    Calculates the neccessary data needed to compute the A matrix. Thus, this function returns both the unique api calls 
    found and what APIs are found in each app.
    
    :param: smali_dict: A dictionary where each key is a unique benign app and each value is a list of its respective
                        files.
                        
    :param: malware_dict: A dictionary where each key is a unique malware app and each value is a list of its respective
                          files.
                                
    :return: api_calls:    A dictionary of apis where each apis value is a unique identifier.
    :return: apis_per_app: A dictionary of apps where each apps value is a list of smali filepaths
    """

    api_calls = defaultdict(int)
    apis_per_app = defaultdict(list)
    api_idx = 0
    
    print('Calculating A Matrix data on Benign Apps...')

    for app in smali_dict:
        apis_per_app[app] = [] 
        for file in smali_dict[app]:
            parsed_file = parseSmaliFile(open(file))
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    api = api_call.replace('\n','').split(' ')[-1]
                    if api not in api_calls:
                        api_calls[api] = api_idx
                        api_idx += 1
                    apis_per_app[app].extend([api_calls[api]])
    print('Calculating A Matrix data on Malware Apps...')

    for app in malware_dict:
        apis_per_app[app] = [] # Just incase a smali folder does not contain any smali files
        for file in malware_dict[app]:
            parsed_file = parseSmaliFile(open(file))
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    api = api_call.replace('\n','').split(' ')[-1]
                    if api not in api_calls:
                        api_calls[api] = api_idx
                        api_idx += 1
                    apis_per_app[app].extend([api_calls[api]])
    
    return api_calls, apis_per_app

# ---------------------------------------------------------------------
# A_matrix_func (WORKING)
# ---------------------------------------------------------------------    

def A_matrix_func(api_calls, apis_per_app):
    """
    This function helps create the inital A matrix given its parameters.
    
    :param: api_calls:    A dictionary of apis where each apis value is a unique identifier.
    :param: apis_per_app: A dictionary of apps where each apps value is a list of smali filepaths
    
    :return: matrix: The calculated A matrix (apps x api)
    """
    i = len(apis_per_app.keys())
    j = len(api_calls) 
    matrix = lil_matrix((i, j), dtype=np.int8)
    print(matrix.shape)
    app_idx = 0
    for app in tqdm(apis_per_app.keys()):
        for apis in apis_per_app[app]:
            matrix[app_idx,apis] = 1
        app_idx += 1
    return matrix

# ---------------------------------------------------------------------
# B_matrix_calc (WORKING)
# ---------------------------------------------------------------------    
def B_matrix_calc(smali_dict, malware_dict):
    """
    Calculates the neccessary data needed to compute the B matrix. Thus, this function returns both the unique api calls
    found and what APIs were found in the same code block.
    
    :param: smali_dict: A dictionary where each key is a unique benign app and each value is a list of its respective
                        files.
    :param: malware_dict: A dictionary where each key is a unique malware app and each value is a list of its respective
                          files.
                        
                        
    :return: api_calls: A dictionary of apis where each apis value is a unique identifier.
    :return: code_blocks: A dictionary of apps where each apps value is a list of apis that occured in the same
                          code block.
    """
    api_calls = defaultdict(int)
    code_blocks = defaultdict(list)
    api_idx = 0
    code_block_idx = 0

    print('Calculating B Matrix data on Benign Apps...')
    for app in smali_dict:
        for file in smali_dict[app]:
            parsed_file = parseSmaliFile(open(file))
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    api = api_call.replace('\n','').split(' ')[-1]
                    if api not in api_calls:
                        api_calls[api] = api_idx
                        api_idx += 1
                    code_blocks[code_block_idx] += [api_calls[api]]
                code_block_idx += 1
                
    print('Calculating B Matrix data on Malware Apps...')            
    for app in malware_dict:
        for file in malware_dict[app]:
            parsed_file = parseSmaliFile(open(file))
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    api = api_call.replace('\n','').split(' ')[-1]
                    if api not in api_calls:
                        api_calls[api] = api_idx
                        api_idx += 1
                    code_blocks[code_block_idx] += [api_calls[api]]
                code_block_idx += 1
    
    return api_calls, code_blocks

# ---------------------------------------------------------------------
# B_matrix_func (WORKING)
# ---------------------------------------------------------------------    
def B_matrix_func(api_calls, code_blocks):
    """
    This function helps create the inital A matrix given its parameters.
    
    :param: api_calls:   A dictionary of apis where each apis value is a unique identifier.
    :param: code_blocks: A dictionary of apps where each apps value is a list of apis that occured in the same
                         code block.
    
    :return: matrix: The calculated B matrix 
    """
    i = len(api_calls) 
    j = len(api_calls) 
    matrix = lil_matrix((i, j), dtype=np.int8)
    idx = []
    for apis in code_blocks.values():
        if len(apis) >= 2:
            pairs = [(apis[i],apis[j]) for i in range(len(apis)) for j in range(i+1,len(apis))]
            idx.extend(pairs)
    idx_ = set(idx)
    for i in list(idx_):
        matrix[i] = 1
    return matrix


# ---------------------------------------------------------------------
# P_matrix_calc (WORKING)
# ---------------------------------------------------------------------        
def P_matrix_calc(smali_dict, malware_dict):
    """
    Calculates the neccessary data needed to compute the P matrix. Thus, this function returns both the unique api calls
    found and what APIs were found in the same code block.
    
    :param: smali_dict: A dictionary where each key is a unique benign app and each value is a list of its respective
                        files.
    :param: malware_dict: A dictionary where each key is a unique malware app and each value is a list of its respective
                        files.
                        
                        
    :return: api_calls: A dictionary of apis where each apis value is a unique identifier.
    :return: packages: A dictionary of apps where each apps value is a list of apis that occured in the same package.
    """
    api_calls = defaultdict(int)
    packages = defaultdict(list)
    api_idx = 0
    
    def permute(lst):
        """ 
        Helper function to permute values found in a list.
        
        :param: lst: An object of type(list)
        :return: tups: permuted tuple pairs required for updating packages
        """
        tups = []
        tup = []
        if len(lst) > 1:
            tup = [(lst[i],lst[j]) for i in range(len(lst)) for j in range(i+1, len(lst))]
        tups.extend(tup)
        return tups
    
    print('Calculating P Matrix data on Benign Apps...')
    for app in smali_dict:
        for file in smali_dict[app]:
            parsed_file = parseSmaliFile(open(file))
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    api = api_call.replace('\n','').split(' ')[-1]
                    if api not in api_calls:
                        api_calls[api] = api_idx
                        api_idx += 1         
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    package = api_call.split('->')[0].split(' ')[-1]
                    api = api_call.replace('\n','').split(' ')[-1]
                    if package not in packages:
                        packages[package] = [api_calls[api]]
                    else:
                        if api_calls[api] not in packages[package]:
                            packages[package].append(api_calls[api])
                       
    print('Calculating P Matrix data on Malware Apps...')
    for app in malware_dict:
        for file in malware_dict[app]:
            parsed_file = parseSmaliFile(open(file))
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    api = api_call.replace('\n','').split(' ')[-1]
                    if api not in api_calls:
                        api_calls[api] = api_idx
                        api_idx += 1
            for method in parsed_file['Methods']:
                for api_call in method['Android API']:
                    package = api_call.split('->')[0].split(' ')[-1]
                    api = api_call.replace('\n','').split(' ')[-1]
                    if package not in packages:
                        packages[package] = [api_calls[api]]
                    else:
                        if api_calls[api] not in packages[package]:
                            packages[package].append(api_calls[api])
                            
    for val in packages.keys():
        packages[val] = permute(packages[val])
    packages = [item for sublist in list(packages.values()) for item in sublist]                 

    
    return api_calls, packages

# ---------------------------------------------------------------------
# smali_mover (WORKING)
# ---------------------------------------------------------------------    
def P_matrix_func(api_calls, packages):
    """
    This function helps create the inital A matrix given its parameters.
    
    :param: api_calls: A dictionary of apis where each apis value is a unique identifier.
    :param: packages: A dictionary of apps where each apps value is a list of apis that occured in the same package.
    
    :return: matrix: The calculated P matrix
    """
    i = len(api_calls)
    j = len(api_calls)
    matrix = lil_matrix((i,j), dtype=np.int8)
    for package in packages:
        matrix[package] = 1
        matrix[(package[1],package[0])] = 1
    return matrix