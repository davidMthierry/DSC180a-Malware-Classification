# Imports 
import os
import re
import bs4
import gzip
import json
import shutil  
import requests
import subprocess
import numpy as np
import pandas as pd
from tqdm import tqdm
import networkx as nx
from bs4 import BeautifulSoup
import xml.etree.ElementTree as ET
from collections import defaultdict
from scipy.sparse import lil_matrix
from sklearn import svm


# ---------------------------------------------------------------------
# Get Data (WORKING)
# ---------------------------------------------------------------------

def get_data(**cfg):
    """
    This function scrapes benign Android application files from APKPure.com based on 
    parameters defined in the file >>> config/data-params.json . 

    :param: Category: The type of application to be downloaded
    :param: Pages: The number of pages of an application type to search from.
    :param: Num: Number of apps to be downloaded from a given category.
    :param: Outpath: This is the location in which our scraped data will be stored.

    :param: Keep_Apks: Boolean variable allowing us to save the application (default = False), 
            if True, both APKs and Smali files will be saved in memory. 

    :return: urls: A list of all the URL's from which we downloaded our apps.
             smali_folders: A list of the names of the smali folders found in /data
    """
    
    def nav_sitemap(cat, page):
        url = 'https://apkpure.com/sitemaps/{0}-{1}.xml.gz'.format(cat,page)
        resp = requests.get(url)
        sitemap = gzip.decompress(resp.content)
        soup = bs4.BeautifulSoup(sitemap, features='lxml')
        return soup

    
    def get_page(xml, x):
        url = xml.find_all('loc')[x].text + '/download?from=details'
        resp = requests.get(url)
        urls.extend([url])
        soup = bs4.BeautifulSoup(resp.text, features='lxml')
        url = soup.find_all('a',{"id": "download_link"})[0]['href']
        resp = requests.get(url)
        content = resp.content
        return content
    
    
    category, pages, num, outpath = cfg['category'], cfg['pages'], cfg['num'], cfg['outpath']
    keep_apks = False

    if os.path.isdir(outpath)==False: os.mkdir(outpath)   
    urls = []
    smali_folders = []
    for cat in category:
        for page in pages:
            try:
                xml = nav_sitemap(cat, page)
                for x in range(0, int(num)):
                    content = get_page(xml, x)
                    
                    # USING APKTOOL 
                    with open('{0}/{1}-{2}-{3}.apk'.format(outpath,cat,page,x), 'wb') as f:
                        f.write(content)
                        
                    subprocess.call(['apktool',
                                 'd',
                                 '{0}/{1}-{2}-{3}.apk'.format(outpath,cat,page,x),
                                 '-o',
                                 '{0}/{1}-{2}-{3}'.format(outpath,cat,page,x)], 
                                stderr=subprocess.STDOUT)
                
                    smali_folders.extend(['{0}-{1}-{2}'.format(cat,page,x)])
                    if keep_apks == False:
                        os.remove('data/{1}-{2}-{3}.apk'.format(outpath,cat,page,x))
                    # END USING APKTOOL 
                    
            except:
                print("There was an issue downloading an app from {0}-{1}".format(cat, page))
                
    return urls, smali_folders

# ---------------------------------------------------------------------
# smali_mover (WORKING)
# --------------------------------------------------------------------- 

def smali_mover(smali_folders):
    """
    This function assists in organizing our data folder. After running get_data(), Smali file 
    folders are stored in the data directory. Running this function collects all Smali file folders
    and creates a new directory in /data called /data/Smali. The Smali folder contains all benign 
    Smali folders for the apps we just downloaded. 

    :param: smali_folders: A list of the names of the Smali File folders found in /data.
    :return: None
    """
    smali_filepath = str(os.getcwd()) + '/' + 'data' + '/' + 'Smali'
    smali_filepath = smali_filepath.replace('\\', '/')
    base_directory = os.getcwd()
    # Check for directory, if not found create a directory
    if not os.path.exists(smali_filepath): os.mkdir(smali_filepath)  
    for smali_folder in smali_folders:
        file_path = str(os.getcwd()) + '/data/' + smali_folder
        file_path = file_path.replace('\\', '/')
        dest = shutil.move(file_path, smali_filepath)   
    return 'Done'


# ---------------------------------------------------------------------
# apk_mover (WORKING)
# ---------------------------------------------------------------------

def apk_mover(file_names):
    """
    This function assists in organizing our data folder. After running get_data(), Android Application (apk) file(s) are 
    stored in the data directory. Running this function collects all apk files and creates a new directory
    in /data called /data/APKs. The APKs folder contains all benign Android Applications that were just downloaded.

    *** Note that this function is only needed if cfg['keep_apks'] == 1, otherwise we dont need this. ***
    """
    apk_directory = str(os.getcwd()) + '/' + 'data' + '/' + 'APKs'
    apk_directory = apk_directory.replace('\\', '/')
    base_directory = os.getcwd()
    # Check for directory, if not found create a directory
    if not os.path.exists(apk_directory): os.mkdir(apk_directory)  
    for files in file_names:
        file_path = str(os.getcwd()) + '/' + 'data' + '/' + files + '.apk'
        file_path = file_path.replace('\\', '/')
        dest = shutil.move(file_path, apk_directory)   
    return 'Done'

# ---------------------------------------------------------------------
# get_smali_files_per_app (WORKING)
# ---------------------------------------------------------------------

def get_smali_files_per_app():
    """
    This function assists in getting each of the smali file paths from a given directory. 

    :param: The input for this function is the path to the directory containing all of our smali files. 
            In the default case, this would be 'data/Smali'.

    :return: app_dictionary: This function returns a dictionary. This dictionary is organized in the following format, 
         Keys : App Names,
         Values : A list of Smali file paths found in each app. 
    """
    DIRECTORY = 'data/Smali'
    original_directory = str(os.getcwd())
    smali_path = original_directory + "\\" + str(DIRECTORY) 
    smali_path = smali_path.replace('\\', '/')
    app_dictionary = defaultdict(str)
    smali_files = []
    os.chdir(smali_path)

    for app in os.listdir():
        if app != '.ipynb.checkpoints':
            app_dictionary[app] = []
    os.chdir(original_directory)
    
    # Obtain all smali files
    for r, d, f in os.walk(smali_path):
        for item in f:
            if '.smali' in item:
                smali_files.append(os.path.join(r, item))
    
    # Populate dictionary with respective files 
    for app in app_dictionary.keys():
        for file in smali_files:
            if re.search(app, file):
                app_dictionary[app].append(file)
    return app_dictionary

# ---------------------------------------------------------------------
# find_malware_filepaths (WORKING)
# ---------------------------------------------------------------------

def find_malware_filepaths():
    """
    This function assists in getting each of the malware smali file paths from a given directory. 
    For the sake of this assignment, our Malware data is stored securely on UCSD-SDSC servers. 
    This function works only when ran on DSMLP servers provided to students by UCSD.  

    :param: The input for this function is the path to the directory containing all of our malware smali files. 
            In the default case, this would be '/datasets/dsc180a-wi20-public/Malware/amd_data_smali/'.

    :return: A list of malware app path names. 
    """
    
    MALWARE = "/datasets/dsc180a-wi20-public/Malware/amd_data_smali/"
 
    def walk_with_depth(fp, level=1):
        """
        This helper function iterates through the given directory. 

        :param: fp: The specified directory path to begin searching from. 
                level: The depth we want to search to.   
        """
        fp = fp.rstrip(os.path.sep)
        assert os.path.isdir(fp)
        sep_count = fp.count(os.path.sep)
        for root, folders, files in os.walk(fp):
            yield root, folders, files
            sep_count_this = root.count(os.path.sep)
            if sep_count + level <= sep_count_this:
                del folders[:]

    gen = walk_with_depth(MALWARE, level=2)
    malware_apps = []
    i=0
    while True:
        try:
            n = next(gen)
            if 'variety' in n[0]:
                for aid in n[1]:
                    malware_apps += [n[0] + "/" + aid + "/smali/"]
            i+=1
        except StopIteration:
            break
    return malware_apps

# ---------------------------------------------------------------------
# sample_malware (WORKING)
# ---------------------------------------------------------------------

def sample_malware(full_malware_list, num_benign):
    """
    This function randomly samples Malware apps and their respective Smali filepaths found from the provided
    Malware Smali File dataset. The reason for this function is because get_malware_filepaths will get the 
    file paths of all Malware apps given to us. We need to make sure that we have the same amount of Malware 
    and Benign apps to train our classifier.

    :param: full_malware_list: The full dictionary of Malware App Names (key) with a list of their 
                                     respective Malware Smali filepaths.
    :param: num_benign: We need to have the same number of Malware and Benign apps in our training and test 
                        datsets, so this is the number of apps found in the benign dictionary. 

    """
    m_smali_fps = []
    for app in np.random.choice(full_malware_list, size = num_benign, replace = False):
        m_smali_fps.append(app)
    return m_smali_fps               
    
# ---------------------------------------------------------------------
# get_malware_smali_files_per_app (WORKING)
# ---------------------------------------------------------------------

def get_malware_smali_files_per_app(sampled_m_apps):
    """
    This function assists in getting each of the malware smali file paths from a given directory. 

    :param: The input for this function is the path to the directory containing all of our malwwar smali 
            files. In this case, the filepaths of a Malware app are found as the values of malware_dict[app].

    :return: app_dictionary: This function returns a dictionary. This dictionary is organized in the following format, 
         Keys : Malware App Names,
         Values : A list of Smali file paths found in each app. 
    """
    
    def navigate_smali(directory):
        """
        Navigate through all of the files in each app and return all of the filepaths
        of every .smali file
        """
        gen = os.walk(directory)
        smali_files = []
        i=0
        while True:
            try:
                n = next(gen)
                for file in n[2]:
                    if '.smali' in file:
                        smali_files += [n[0]+"/"+file]
                i+=1
            except StopIteration:
                break
        return smali_files
    
    malware_dict = {}
    for directory in sampled_m_apps:
        malware_dict[directory] = navigate_smali(directory)
        
    return malware_dict



# ---------------------------------------------------------------------
# split_dictionary (WORKING)
# ---------------------------------------------------------------------

def split_dictionary(app_dict):
    """
    Given a dictionary, split it into two equal length dictionaries. 
    
    :params: A dictionary object. 
    :return: Two even length dictionaries containing all of the keys from the orignal dictionary.
    """
    apps = [app for app in app_dict.keys() if app != '.ipynb_checkpoints']
    train_keys = np.random.choice(apps , len(apps)//2, replace = False)
    train_subdict = {app: app_dict[app] for app in train_keys if app in app_dict}
    test_keys = [key for key in apps if key not in train_subdict.keys()]
    test_subdict = {app: app_dict[app] for app in test_keys if app in app_dict}
    
    return train_subdict, test_subdict
